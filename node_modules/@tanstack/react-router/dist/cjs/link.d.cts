import { ParsedLocation } from './location.cjs';
import { HistoryState } from '@tanstack/history';
import { AllParams, CatchAllPaths, CurrentPath, FullSearchSchema, FullSearchSchemaInput, ParentPath, RouteByPath, RouteByToPath, RoutePaths, RouteToPath, TrailingSlashOptionByRouter } from './routeInfo.cjs';
import { AnyRouter, RegisteredRouter } from './router.cjs';
import { Constrain, Expand, MakeDifferenceOptional, NoInfer, NonNullableUpdater, PickRequired, Updater, WithoutEmpty } from './utils.cjs';
import { ReactNode } from 'react';
import * as React from 'react';
export type CleanPath<T extends string> = T extends `${infer L}//${infer R}` ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`> : T extends `${infer L}//` ? `${CleanPath<L>}/` : T extends `//${infer L}` ? `/${CleanPath<L>}` : T;
export type Split<TValue, TIncludeTrailingSlash = true> = TValue extends unknown ? string extends TValue ? Array<string> : TValue extends string ? CleanPath<TValue> extends '' ? [] : TIncludeTrailingSlash extends true ? CleanPath<TValue> extends `${infer T}/` ? [...Split<T>, '/'] : CleanPath<TValue> extends `/${infer U}` ? Split<U> : CleanPath<TValue> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : [TValue] : CleanPath<TValue> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : TValue extends string ? [TValue] : never : never : never;
export type ParsePathParams<T extends string, TAcc = never> = T extends `${string}$${string}` ? T extends `${string}$${infer TPossiblyParam}` ? TPossiblyParam extends `${string}/${string}` ? TPossiblyParam extends `${infer TParam}/${infer TRest}` ? ParsePathParams<TRest, TParam extends '' ? TAcc : TParam | TAcc> : never : TPossiblyParam extends '' ? TAcc : TPossiblyParam | TAcc : TAcc : TAcc;
export type Join<T, TDelimiter extends string = '/'> = T extends [] ? '' : T extends [infer L extends string] ? L : T extends [
    infer L extends string,
    ...infer Tail extends [...Array<string>]
] ? CleanPath<`${L}${TDelimiter}${Join<Tail>}`> : never;
export type Last<T extends Array<any>> = T extends [...infer _, infer L] ? L : never;
export type AddTrailingSlash<T> = T extends `${string}/` ? T : `${T & string}/`;
export type RemoveTrailingSlashes<T> = T extends `${infer R}/` ? R : T;
export type RemoveLeadingSlashes<T> = T extends `/${infer R}` ? R : T;
export type ResolvePaths<TRouter extends AnyRouter, TSearchPath> = RouteByPath<TRouter['routeTree'], RemoveTrailingSlashes<TSearchPath>> extends never ? RouteToPath<TRouter, TRouter['routeTree']> : RouteToPath<TRouter, RouteByPath<TRouter['routeTree'], RemoveTrailingSlashes<TSearchPath>>>;
export type SearchPaths<TRouter extends AnyRouter, TSearchPath extends string, TPaths = ResolvePaths<TRouter, TSearchPath>, TPrefix extends string = `${RemoveTrailingSlashes<TSearchPath>}/`, TFilteredPaths = TPaths & `${TPrefix}${string}`> = TFilteredPaths extends `${TPrefix}${infer TRest}` ? TRest : never;
export type SearchRelativePathAutoComplete<TRouter extends AnyRouter, TTo extends string, TSearchPath extends string> = `${TTo}/${SearchPaths<TRouter, TSearchPath>}`;
export type RelativeToParentPathAutoComplete<TRouter extends AnyRouter, TFrom extends string, TTo extends string, TResolvedPath extends string = RemoveTrailingSlashes<ResolveRelativePath<TFrom, TTo>>> = SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath> | (TResolvedPath extends '' ? never : `${TTo}/${ParentPath<TrailingSlashOptionByRouter<TRouter>>}`);
export type RelativeToCurrentPathAutoComplete<TRouter extends AnyRouter, TFrom extends string, TTo extends string, TResolvedPath extends string = ResolveRelativePath<TFrom, TTo>> = SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath> | CurrentPath<TrailingSlashOptionByRouter<TRouter>>;
export type AbsolutePathAutoComplete<TRouter extends AnyRouter, TFrom extends string> = (string extends TFrom ? CurrentPath<TrailingSlashOptionByRouter<TRouter>> : TFrom extends `/` ? never : SearchPaths<TRouter, TFrom> extends '' ? never : CurrentPath<TrailingSlashOptionByRouter<TRouter>>) | (string extends TFrom ? ParentPath<TrailingSlashOptionByRouter<TRouter>> : TFrom extends `/` ? never : ParentPath<TrailingSlashOptionByRouter<TRouter>>) | RouteToPath<TRouter, TRouter['routeTree']> | (TFrom extends '/' ? never : string extends TFrom ? never : RemoveLeadingSlashes<SearchPaths<TRouter, TFrom>>);
export type RelativeToPathAutoComplete<TRouter extends AnyRouter, TFrom extends string, TTo extends string> = string extends TFrom ? AbsolutePathAutoComplete<TRouter, TFrom> : TTo extends `..${string}` ? RelativeToParentPathAutoComplete<TRouter, TFrom, RemoveTrailingSlashes<TTo>> : TTo extends `.${string}` ? RelativeToCurrentPathAutoComplete<TRouter, TFrom, RemoveTrailingSlashes<TTo>> : AbsolutePathAutoComplete<TRouter, TFrom>;
export type NavigateOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = '.', TMaskFrom extends string = TFrom, TMaskTo extends string = '.'> = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & NavigateOptionProps;
export interface NavigateOptionProps {
    replace?: boolean;
    resetScroll?: boolean;
    /** @deprecated All navigations now use startTransition under the hood */
    startTransition?: boolean;
    viewTransition?: boolean;
    ignoreBlocker?: boolean;
}
export type ToOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = '.', TMaskFrom extends string = TFrom, TMaskTo extends string = '.'> = ToSubOptions<TRouter, TFrom, TTo> & MaskOptions<TRouter, TMaskFrom, TMaskTo>;
export interface MaskOptions<in out TRouter extends AnyRouter, in out TMaskFrom extends string, in out TMaskTo extends string> {
    _fromLocation?: ParsedLocation;
    mask?: ToMaskOptions<TRouter, TMaskFrom, TMaskTo>;
}
export type ToMaskOptions<TRouteTree extends AnyRouter = RegisteredRouter, TMaskFrom extends string = string, TMaskTo extends string = '.'> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {
    unmaskOnReload?: boolean;
};
export type ToSubOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = '.'> = ToSubOptionsProps<TRouter, TFrom, TTo> & SearchParamOptions<TRouter, TFrom, TTo> & PathParamOptions<TRouter, TFrom, TTo>;
export interface ToSubOptionsProps<in out TRouter extends AnyRouter = RegisteredRouter, in out TFrom extends RoutePaths<TRouter['routeTree']> | string = string, in out TTo extends string | undefined = '.'> {
    to?: ToPathOption<TRouter, TFrom, TTo> & {};
    hash?: true | Updater<string>;
    state?: true | NonNullableUpdater<HistoryState>;
    from?: FromPathOption<TRouter, TFrom> & {};
}
export type ParamsReducerFn<in out TRouter extends AnyRouter, in out TParamVariant extends ParamVariant, in out TFrom, in out TTo> = (current: Expand<ResolveFromParams<TRouter, TParamVariant, TFrom>>) => Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>;
type ParamsReducer<TRouter extends AnyRouter, TParamVariant extends ParamVariant, TFrom, TTo> = Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>> | (ParamsReducerFn<TRouter, TParamVariant, TFrom, TTo> & {});
type ParamVariant = 'PATH' | 'SEARCH';
export type ResolveRoute<TRouter extends AnyRouter, TFrom, TTo, TPath = ResolveRelativePath<TFrom, TTo>> = TPath extends string ? TFrom extends TPath ? RouteByPath<TRouter['routeTree'], TPath> : RouteByToPath<TRouter, TPath> : never;
type ResolveFromParamType<TParamVariant extends ParamVariant> = TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchema';
type ResolveFromAllParams<TRouter extends AnyRouter, TParamVariant extends ParamVariant> = TParamVariant extends 'PATH' ? AllParams<TRouter['routeTree']> : FullSearchSchema<TRouter['routeTree']>;
type ResolveFromParams<TRouter extends AnyRouter, TParamVariant extends ParamVariant, TFrom> = string extends TFrom ? ResolveFromAllParams<TRouter, TParamVariant> : RouteByPath<TRouter['routeTree'], TFrom>['types'][ResolveFromParamType<TParamVariant>];
type ResolveToParamType<TParamVariant extends ParamVariant> = TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchemaInput';
type ResolveAllToParams<TRouter extends AnyRouter, TParamVariant extends ParamVariant> = TParamVariant extends 'PATH' ? AllParams<TRouter['routeTree']> : FullSearchSchemaInput<TRouter['routeTree']>;
export type ResolveToParams<TRouter extends AnyRouter, TParamVariant extends ParamVariant, TFrom, TTo> = ResolveRelativePath<TFrom, TTo> extends infer TPath ? undefined extends TPath ? never : string extends TPath ? ResolveAllToParams<TRouter, TParamVariant> : TPath extends CatchAllPaths<TrailingSlashOptionByRouter<TRouter>> ? ResolveAllToParams<TRouter, TParamVariant> : ResolveRoute<TRouter, TFrom, TTo>['types'][ResolveToParamType<TParamVariant>] : never;
type ResolveRelativeToParams<TRouter extends AnyRouter, TParamVariant extends ParamVariant, TFrom, TTo, TToParams = ResolveToParams<TRouter, TParamVariant, TFrom, TTo>> = TParamVariant extends 'SEARCH' ? TToParams : string extends TFrom ? TToParams : MakeDifferenceOptional<ResolveFromParams<TRouter, TParamVariant, TFrom>, TToParams>;
export interface MakeOptionalSearchParams<in out TRouter extends AnyRouter, in out TFrom, in out TTo> {
    search?: true | (ParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {});
}
export interface MakeOptionalPathParams<in out TRouter extends AnyRouter, in out TFrom, in out TTo> {
    params?: true | (ParamsReducer<TRouter, 'PATH', TFrom, TTo> & {});
}
type MakeRequiredParamsReducer<TRouter extends AnyRouter, TParamVariant extends ParamVariant, TFrom, TTo> = (string extends TFrom ? never : ResolveFromParams<TRouter, TParamVariant, TFrom> extends WithoutEmpty<PickRequired<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>> ? true : never) | (ParamsReducer<TRouter, TParamVariant, TFrom, TTo> & {});
export interface MakeRequiredPathParams<in out TRouter extends AnyRouter, in out TFrom, in out TTo> {
    params: MakeRequiredParamsReducer<TRouter, 'PATH', TFrom, TTo> & {};
}
export interface MakeRequiredSearchParams<in out TRouter extends AnyRouter, in out TFrom, in out TTo> {
    search: MakeRequiredParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {};
}
export type IsRequiredParams<TParams> = Record<never, never> extends TParams ? never : true;
export type IsRequired<TRouter extends AnyRouter, TParamVariant extends ParamVariant, TFrom, TTo> = ResolveRelativePath<TFrom, TTo> extends infer TPath ? undefined extends TPath ? never : TPath extends CatchAllPaths<TrailingSlashOptionByRouter<TRouter>> ? never : IsRequiredParams<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>> : never;
export type SearchParamOptions<TRouter extends AnyRouter, TFrom, TTo> = IsRequired<TRouter, 'SEARCH', TFrom, TTo> extends never ? MakeOptionalSearchParams<TRouter, TFrom, TTo> : MakeRequiredSearchParams<TRouter, TFrom, TTo>;
export type PathParamOptions<TRouter extends AnyRouter, TFrom, TTo> = IsRequired<TRouter, 'PATH', TFrom, TTo> extends never ? MakeOptionalPathParams<TRouter, TFrom, TTo> : MakeRequiredPathParams<TRouter, TFrom, TTo>;
export type ToPathOption<TRouter extends AnyRouter = AnyRouter, TFrom extends string = string, TTo extends string | undefined = string> = CheckPath<TRouter, TTo, never, TFrom, TTo> | RelativeToPathAutoComplete<TRouter, NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
export type CheckFromPath<TRouter extends AnyRouter, TPass, TFail, TFrom> = string extends TFrom ? TPass : RouteByPath<TRouter['routeTree'], TFrom> extends never ? TFail : TPass;
export type FromPathOption<TRouter extends AnyRouter, TFrom> = CheckFromPath<TRouter, string extends TFrom ? TFrom & {} : TFrom, never, TFrom> | RoutePaths<TRouter['routeTree']>;
export interface ActiveOptions {
    exact?: boolean;
    includeHash?: boolean;
    includeSearch?: boolean;
}
export type LinkOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = '.', TMaskFrom extends string = TFrom, TMaskTo extends string = '.'> = NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & LinkOptionsProps;
export interface LinkOptionsProps {
    /**
     * The standard anchor tag target attribute
     */
    target?: HTMLAnchorElement['target'];
    /**
     * Configurable options to determine if the link should be considered active or not
     * @default {exact:true,includeHash:true}
     */
    activeOptions?: ActiveOptions;
    /**
     * The preloading strategy for this link
     * - `false` - No preloading
     * - `'intent'` - Preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.
     * - `'viewport'` - Preload the linked route when it enters the viewport
     */
    preload?: false | 'intent' | 'viewport';
    /**
     * When a preload strategy is set, this delays the preload by this many milliseconds.
     * If the user exits the link before this delay, the preload will be cancelled.
     */
    preloadDelay?: number;
    /**
     * Control whether the link should be disabled or not
     * If set to `true`, the link will be rendered without an `href` attribute
     * @default false
     */
    disabled?: boolean;
}
export type CheckPath<TRouter extends AnyRouter, TPass, TFail, TFrom, TTo> = string extends ResolveRelativePath<TFrom, TTo> ? TPass : ResolveRelativePath<TFrom, TTo> extends CatchAllPaths<TrailingSlashOptionByRouter<TRouter>> ? TPass : ResolveRoute<TRouter, TFrom, TTo> extends never ? TFail : TPass;
export type ResolveRelativePath<TFrom, TTo = '.'> = string extends TFrom ? TTo : string extends TTo ? TFrom : undefined extends TTo ? TFrom : TFrom extends string ? TTo extends string ? TTo extends '.' ? TFrom : TTo extends `./` ? Join<[TFrom, '/']> : TTo extends `./${infer TRest}` ? ResolveRelativePath<TFrom, TRest> : TTo extends `/${infer TRest}` ? TTo : Split<TTo> extends ['..', ...infer ToRest] ? Split<TFrom> extends [...infer FromRest, infer FromTail] ? ToRest extends ['/'] ? Join<['/', ...FromRest, '/']> : ResolveRelativePath<Join<FromRest>, Join<ToRest>> : never : Split<TTo> extends ['.', ...infer ToRest] ? ToRest extends ['/'] ? Join<[TFrom, '/']> : ResolveRelativePath<TFrom, Join<ToRest>> : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>> : never : never;
export declare function useLinkProps<TRouter extends AnyRouter = RegisteredRouter, TFrom extends RoutePaths<TRouter['routeTree']> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom, TMaskTo extends string = ''>(options: UseLinkPropsOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>, forwardedRef?: React.ForwardedRef<Element>): React.ComponentPropsWithRef<'a'>;
type UseLinkReactProps<TComp> = TComp extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[TComp] : React.PropsWithoutRef<TComp extends React.ComponentType<infer TProps> ? TProps : never> & React.RefAttributes<TComp extends React.FC<{
    ref: infer TRef;
}> | React.Component<{
    ref: infer TRef;
}> ? TRef : never>;
export type UseLinkPropsOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends RoutePaths<TRouter['routeTree']> | string = string, TTo extends string | undefined = '.', TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom, TMaskTo extends string = '.'> = ActiveLinkOptions<'a', TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & UseLinkReactProps<'a'>;
export type ActiveLinkOptions<TComp = 'a', TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = '.', TMaskFrom extends string = TFrom, TMaskTo extends string = '.'> = LinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & ActiveLinkOptionProps<TComp>;
type ActiveLinkProps<TComp> = Partial<LinkComponentReactProps<TComp> & {
    [key: `data-${string}`]: unknown;
}>;
export interface ActiveLinkOptionProps<TComp = 'a'> {
    /**
     * A function that returns additional props for the `active` state of this link.
     * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)
     */
    activeProps?: ActiveLinkProps<TComp> | (() => ActiveLinkProps<TComp>);
    /**
     * A function that returns additional props for the `inactive` state of this link.
     * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)
     */
    inactiveProps?: ActiveLinkProps<TComp> | (() => ActiveLinkProps<TComp>);
}
export type LinkProps<TComp = 'a', TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = '.', TMaskFrom extends string = TFrom, TMaskTo extends string = '.'> = ActiveLinkOptions<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & LinkPropsChildren;
export interface LinkPropsChildren {
    children?: React.ReactNode | ((state: {
        isActive: boolean;
        isTransitioning: boolean;
    }) => React.ReactNode);
}
type LinkComponentReactProps<TComp> = Omit<UseLinkReactProps<TComp>, keyof CreateLinkProps>;
export type LinkComponentProps<TComp = 'a', TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = '.', TMaskFrom extends string = TFrom, TMaskTo extends string = '.'> = LinkComponentReactProps<TComp> & LinkProps<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo>;
export type CreateLinkProps = LinkProps<any, any, string, string, string, string>;
export type LinkComponent<TComp> = <TRouter extends RegisteredRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = undefined, TMaskFrom extends string = TFrom, TMaskTo extends string = ''>(props: LinkComponentProps<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo>) => React.ReactElement;
export declare function createLink<const TComp>(Comp: Constrain<TComp, any, (props: CreateLinkProps) => ReactNode>): LinkComponent<TComp>;
export declare const Link: LinkComponent<'a'>;
export {};
