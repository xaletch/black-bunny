import { Store, NoInfer } from '@tanstack/react-store';
import { HistoryState, RouterHistory } from '@tanstack/history';
import { Manifest } from './manifest.cjs';
import { AnyContext, AnyRoute, AnyRouteWithContext, AnySearchSchema, ErrorRouteComponent, NotFoundRouteComponent, RootRoute, RouteComponent, RouteMask } from './route.cjs';
import { FullSearchSchema, RouteById, RoutePaths, RoutesById, RoutesByPath } from './routeInfo.cjs';
import { ControlledPromise, NonNullableUpdater, PickAsRequired, Updater } from './utils.cjs';
import { AnyRouteMatch, MakeRouteMatch, MatchRouteOptions } from './Matches.cjs';
import { ParsedLocation } from './location.cjs';
import { SearchParser, SearchSerializer } from './searchParams.cjs';
import { BuildLocationFn, CommitLocationOptions, NavigateFn } from './RouterProvider.cjs';
import { AnyRedirect, ResolvedRedirect } from './redirects.cjs';
import { NotFoundError } from './not-found.cjs';
import { NavigateOptions, ResolveRelativePath, ToOptions } from './link.cjs';
import { RouterTransformer } from './transformer.cjs';
import type * as React from 'react';
declare global {
    interface Window {
        __TSR__?: {
            matches: Array<{
                __beforeLoadContext?: string;
                loaderData?: string;
                extracted?: Array<ExtractedEntry>;
            }>;
            streamedValues: Record<string, {
                value: any;
                parsed: any;
            }>;
            cleanScripts: () => void;
            dehydrated?: any;
        };
        __TSR_ROUTER_CONTEXT__?: React.Context<Router<any, any>>;
    }
}
export interface Register {
}
export type AnyRouter = Router<any, any, any, any>;
export type AnyRouterWithContext<TContext> = Router<AnyRouteWithContext<TContext>, any, any, any>;
export type RegisteredRouter = Register extends {
    router: infer TRouter extends AnyRouter;
} ? TRouter : AnyRouter;
export type HydrationCtx = {
    router: DehydratedRouter;
    payload: Record<string, any>;
};
export type InferRouterContext<TRouteTree extends AnyRoute> = TRouteTree extends RootRoute<any, infer TRouterContext extends AnyContext, any, any, any, any, any, any> ? TRouterContext : AnyContext;
export type ExtractedEntry = {
    dataType: '__beforeLoadContext' | 'loaderData';
    type: 'promise' | 'stream';
    path: Array<string>;
    value: any;
    id: number;
    streamState?: StreamState;
    matchIndex: number;
};
export type StreamState = {
    promises: Array<ControlledPromise<string | null>>;
};
export type RouterContextOptions<TRouteTree extends AnyRoute> = AnyContext extends InferRouterContext<TRouteTree> ? {
    context?: InferRouterContext<TRouteTree>;
} : {
    context: InferRouterContext<TRouteTree>;
};
export type TrailingSlashOption = 'always' | 'never' | 'preserve';
export interface RouterOptions<TRouteTree extends AnyRoute, TTrailingSlashOption extends TrailingSlashOption, TDehydrated extends Record<string, any> = Record<string, any>, TSerializedError extends Record<string, any> = Record<string, any>> {
    /**
     * The history object that will be used to manage the browser history.
     *
     * If not provided, a new createBrowserHistory instance will be created and used.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)
     */
    history?: RouterHistory;
    /**
     * A function that will be used to stringify search params when generating links.
     *
     * @default defaultStringifySearch
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)
     */
    stringifySearch?: SearchSerializer;
    /**
     * A function that will be used to parse search params when parsing the current location.
     *
     * @default defaultParseSearch
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)
     */
    parseSearch?: SearchParser;
    /**
     * If `false`, routes will not be preloaded by default in any way.
     *
     * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.
     *
     * If `'viewport'`, routes will be preloaded by default when they are within the viewport.
     *
     * @default false
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)
     */
    defaultPreload?: false | 'intent' | 'viewport';
    /**
     * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.
     *
     * @default 50
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)
     */
    defaultPreloadDelay?: number;
    /**
     * The default `component` a route should use if no component is provided.
     *
     * @default Outlet
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultcomponent-property)
     */
    defaultComponent?: RouteComponent;
    /**
     * The default `errorComponent` a route should use if no error component is provided.
     *
     * @default ErrorComponent
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulterrorcomponent-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)
     */
    defaultErrorComponent?: ErrorRouteComponent;
    /**
     * The default `pendingComponent` a route should use if no pending component is provided.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingcomponent-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#showing-a-pending-component)
     */
    defaultPendingComponent?: RouteComponent;
    /**
     * The default `pendingMs` a route should use if no pendingMs is provided.
     *
     * @default 1000
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)
     */
    defaultPendingMs?: number;
    /**
     * The default `pendingMinMs` a route should use if no pendingMinMs is provided.
     *
     * @default 500
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)
     */
    defaultPendingMinMs?: number;
    /**
     * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.
     *
     * @default 0
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)
     */
    defaultStaleTime?: number;
    /**
     * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.
     *
     * @default 30_000 `(30 seconds)`
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)
     */
    defaultPreloadStaleTime?: number;
    /**
     * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.
     *
     * @default 1_800_000 `(30 minutes)`
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)
     */
    defaultPreloadGcTime?: number;
    /**
     * The default `onCatch` handler for errors caught by the Router ErrorBoundary
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultoncatch-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionsoncatch)
     */
    defaultOnCatch?: (error: Error, errorInfo: React.ErrorInfo) => void;
    /**
     * If `true`, route navigations will called using `document.startViewTransition()`.
     *
     * If the browser does not support this api, this option will be ignored.
     *
     * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)
     */
    defaultViewTransition?: boolean;
    /**
     * @default 'fuzzy'
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)
     */
    notFoundMode?: 'root' | 'fuzzy';
    /**
     * The default `gcTime` a route should use if no gcTime is provided.
     *
     * @default 1_800_000 `(30 minutes)`
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)
     */
    defaultGcTime?: number;
    /**
     * If `true`, all routes will be matched as case-sensitive.
     *
     * @default false
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-trees#case-sensitivity)
     */
    caseSensitive?: boolean;
    /**
     *
     * The route tree that will be used to configure the router instance.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-trees)
     */
    routeTree?: TRouteTree;
    /**
     * The basepath for then entire router. This is useful for mounting a router instance at a subpath.
     *
     * @default '/'
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)
     */
    basepath?: string;
    /**
     * The root context that will be provided to all routes in the route tree.
     *
     * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.
     *
     * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)
     */
    context?: InferRouterContext<TRouteTree>;
    /**
     * A function that will be called when the router is dehydrated.
     *
     * The return value of this function will be serialized and stored in the router's dehydrated state.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)
     */
    dehydrate?: () => TDehydrated;
    /**
     * A function that will be called when the router is hydrated.
     *
     * The return value of this function will be serialized and stored in the router's dehydrated state.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)
     */
    hydrate?: (dehydrated: TDehydrated) => void;
    /**
     * An array of route masks that will be used to mask routes in the route tree.
     *
     * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)
     */
    routeMasks?: Array<RouteMask<TRouteTree>>;
    /**
     * If `true`, route masks will, by default, be removed when the page is reloaded.
     *
     * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.
     *
     * @default false
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)
     */
    unmaskOnReload?: boolean;
    /**
     * A component that will be used to wrap the entire router.
     *
     * This is useful for providing a context to the entire router.
     *
     * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#wrap-property)
     */
    Wrap?: (props: {
        children: any;
    }) => React.JSX.Element;
    /**
     * A component that will be used to wrap the inner contents of the router.
     *
     * This is useful for providing a context to the inner contents of the router where you also need access to the router context and hooks.
     *
     * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#innerwrap-property)
     */
    InnerWrap?: (props: {
        children: any;
    }) => React.JSX.Element;
    /**
     * Use `notFoundComponent` instead.
     *
     * @deprecated
     * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)
     */
    notFoundRoute?: AnyRoute;
    /**
     * The default `notFoundComponent` a route should use if no notFound component is provided.
     *
     * @default NotFound
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultnotfoundcomponent-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#default-router-wide-not-found-handling)
     */
    defaultNotFoundComponent?: NotFoundRouteComponent;
    /**
     * The transformer that will be used when sending data between the server and the client during SSR.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#transformer-property)
     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/ssr#data-transformers)
     */
    transformer?: RouterTransformer;
    /**
     * The serializer object that will be used to determine how errors are serialized and deserialized between the server and the client.
     *
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#errorserializer-property)
     */
    errorSerializer?: RouterErrorSerializer<TSerializedError>;
    /**
     * Configures how trailing slashes are treated.
     *
     * - `'always'` will add a trailing slash if not present
     * - `'never'` will remove the trailing slash if present
     * - `'preserve'` will not modify the trailing slash.
     *
     * @default 'never'
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)
     */
    trailingSlash?: TTrailingSlashOption;
    /**
     * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.
     *
     * @default typeof document !== 'undefined'
     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver property)
     */
    isServer?: boolean;
    defaultSsr?: boolean;
}
export interface RouterErrorSerializer<TSerializedError> {
    serialize: (err: unknown) => TSerializedError;
    deserialize: (err: TSerializedError) => unknown;
}
export interface RouterState<TRouteTree extends AnyRoute = AnyRoute, TRouteMatch = MakeRouteMatch<TRouteTree>> {
    status: 'pending' | 'idle';
    loadedAt: number;
    isLoading: boolean;
    isTransitioning: boolean;
    matches: Array<TRouteMatch>;
    pendingMatches?: Array<TRouteMatch>;
    cachedMatches: Array<TRouteMatch>;
    location: ParsedLocation<FullSearchSchema<TRouteTree>>;
    resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>;
    statusCode: number;
    redirect?: ResolvedRedirect;
}
export type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void;
export interface BuildNextOptions {
    to?: string | number | null;
    params?: true | Updater<unknown>;
    search?: true | Updater<unknown>;
    hash?: true | Updater<string>;
    state?: true | NonNullableUpdater<HistoryState>;
    mask?: {
        to?: string | number | null;
        params?: true | Updater<unknown>;
        search?: true | Updater<unknown>;
        hash?: true | Updater<string>;
        state?: true | NonNullableUpdater<HistoryState>;
        unmaskOnReload?: boolean;
    };
    from?: string;
    _fromLocation?: ParsedLocation;
}
export interface DehydratedRouterState {
    dehydratedMatches: Array<DehydratedRouteMatch>;
}
export type DehydratedRouteMatch = Pick<MakeRouteMatch, 'id' | 'status' | 'updatedAt' | 'loaderData'>;
export interface DehydratedRouter {
    state: DehydratedRouterState;
    manifest?: Manifest;
}
export type RouterConstructorOptions<TRouteTree extends AnyRoute, TTrailingSlashOption extends TrailingSlashOption, TDehydrated extends Record<string, any>, TSerializedError extends Record<string, any>> = Omit<RouterOptions<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>, 'context'> & RouterContextOptions<TRouteTree>;
export declare const componentTypes: readonly ["component", "errorComponent", "pendingComponent", "notFoundComponent"];
export type RouterEvents = {
    onBeforeNavigate: {
        type: 'onBeforeNavigate';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
    onBeforeLoad: {
        type: 'onBeforeLoad';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
    onLoad: {
        type: 'onLoad';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
    onResolved: {
        type: 'onResolved';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
};
export type RouterEvent = RouterEvents[keyof RouterEvents];
export type RouterListener<TRouterEvent extends RouterEvent> = {
    eventType: TRouterEvent['type'];
    fn: ListenerFn<TRouterEvent>;
};
export declare function createRouter<TRouteTree extends AnyRoute, TTrailingSlashOption extends TrailingSlashOption, TDehydrated extends Record<string, any> = Record<string, any>, TSerializedError extends Record<string, any> = Record<string, any>>(options: undefined extends number ? 'strictNullChecks must be enabled in tsconfig.json' : RouterConstructorOptions<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>): Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>;
type MatchRoutesOpts = {
    preload?: boolean;
    throwOnError?: boolean;
};
export declare class Router<in out TRouteTree extends AnyRoute, in out TTrailingSlashOption extends TrailingSlashOption, in out TDehydrated extends Record<string, any> = Record<string, any>, in out TSerializedError extends Record<string, any> = Record<string, any>> {
    tempLocationKey: string | undefined;
    resetNextScroll: boolean;
    shouldViewTransition?: boolean;
    subscribers: Set<RouterListener<RouterEvent>>;
    dehydratedData?: TDehydrated;
    viewTransitionPromise?: ControlledPromise<true>;
    manifest?: Manifest;
    AfterEachMatch?: (props: {
        match: Pick<AnyRouteMatch, 'id' | 'status' | 'error' | 'loadPromise' | 'minPendingPromise'>;
        matchIndex: number;
    }) => any;
    serializeLoaderData?: (type: '__beforeLoadContext' | 'loaderData', loaderData: any, ctx: {
        router: AnyRouter;
        match: AnyRouteMatch;
    }) => any;
    serializer?: (data: any) => string;
    __store: Store<RouterState<TRouteTree>>;
    options: PickAsRequired<Omit<RouterOptions<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>, 'transformer'> & {
        transformer: RouterTransformer;
    }, 'stringifySearch' | 'parseSearch' | 'context'>;
    history: RouterHistory;
    latestLocation: ParsedLocation<FullSearchSchema<TRouteTree>>;
    basepath: string;
    routeTree: TRouteTree;
    routesById: RoutesById<TRouteTree>;
    routesByPath: RoutesByPath<TRouteTree>;
    flatRoutes: Array<AnyRoute>;
    isServer: boolean;
    /**
     * @deprecated Use the `createRouter` function instead
     */
    constructor(options: RouterConstructorOptions<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>);
    startReactTransition: (fn: () => void) => void;
    update: (newOptions: RouterConstructorOptions<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>) => void;
    get state(): RouterState<TRouteTree, MakeRouteMatch<TRouteTree>>;
    buildRouteTree: () => void;
    subscribe: <TType extends keyof RouterEvents>(eventType: TType, fn: ListenerFn<RouterEvents[TType]>) => () => void;
    emit: (routerEvent: RouterEvent) => void;
    parseLocation: (previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>) => ParsedLocation<FullSearchSchema<TRouteTree>>;
    resolvePathWithBase: (from: string, path: string) => string;
    get looseRoutesById(): Record<string, AnyRoute>;
    /**
    @deprecated use the following signature instead
    ```ts
    matchRoutes (
      next: ParsedLocation,
      opts?: { preload?: boolean; throwOnError?: boolean },
    ): Array<AnyRouteMatch>;
    ```
  */
    matchRoutes(pathname: string, locationSearch: AnySearchSchema, opts?: MatchRoutesOpts): Array<AnyRouteMatch>;
    matchRoutes(next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>;
    private matchRoutesInternal;
    cancelMatch: (id: string) => void;
    cancelMatches: () => void;
    buildLocation: BuildLocationFn;
    commitLocationPromise: undefined | ControlledPromise<void>;
    commitLocation: ({ viewTransition, ignoreBlocker, ...next }: ParsedLocation & CommitLocationOptions) => Promise<void>;
    buildAndCommitLocation: ({ replace, resetScroll, viewTransition, ignoreBlocker, ...rest }?: BuildNextOptions & CommitLocationOptions) => Promise<void>;
    navigate: NavigateFn;
    latestLoadPromise: undefined | Promise<void>;
    load: () => Promise<void>;
    startViewTransition: (fn: () => Promise<void>) => void;
    updateMatch: (id: string, updater: (match: AnyRouteMatch) => AnyRouteMatch) => AnyRouteMatch;
    getMatch: (matchId: string) => MakeRouteMatch<TRouteTree> | undefined;
    loadMatches: ({ location, matches, preload, onReady, updateMatch, }: {
        location: ParsedLocation;
        matches: Array<AnyRouteMatch>;
        preload?: boolean;
        onReady?: () => Promise<void>;
        updateMatch?: (id: string, updater: (match: AnyRouteMatch) => AnyRouteMatch) => void;
        getMatch?: (matchId: string) => AnyRouteMatch | undefined;
    }) => Promise<Array<MakeRouteMatch>>;
    invalidate: () => Promise<void>;
    resolveRedirect: (err: AnyRedirect) => ResolvedRedirect;
    cleanCache: () => void;
    preloadRoute: <TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string | undefined = undefined, TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = "">(opts: NavigateOptions<Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>, TFrom, TTo, TMaskFrom, TMaskTo>) => Promise<Array<AnyRouteMatch> | undefined>;
    matchRoute: <TFrom extends RoutePaths<TRouteTree> = "/", TTo extends string | undefined = undefined, TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>>(location: ToOptions<Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>, TFrom, TTo>, opts?: MatchRouteOptions) => false | RouteById<TRouteTree, TResolved>["types"]["allParams"];
    dehydrate: () => DehydratedRouter;
    hydrate: () => void;
    injectedHtml: Array<() => string>;
    injectHtml: (html: string) => void;
    streamedKeys: Set<string>;
    getStreamedValue: <T>(key: string) => T | undefined;
    streamValue: (key: string, value: any) => void;
    _handleNotFound: (matches: Array<AnyRouteMatch>, err: NotFoundError, { updateMatch, }?: {
        updateMatch?: (id: string, updater: (match: AnyRouteMatch) => AnyRouteMatch) => void;
    }) => void;
    hasNotFoundMatch: () => boolean;
}
export declare function lazyFn<T extends Record<string, (...args: Array<any>) => any>, TKey extends keyof T = 'default'>(fn: () => Promise<T>, key?: TKey): (...args: Parameters<T[TKey]>) => Promise<Awaited<ReturnType<T[TKey]>>>;
export declare class SearchParamError extends Error {
}
export declare class PathParamError extends Error {
}
export declare function getInitialRouterState(location: ParsedLocation): RouterState<any>;
export declare function defaultSerializeError(err: unknown): {
    name: string;
    message: string;
} | {
    data: unknown;
};
export {};
