{"version":3,"file":"useLoaderData.cjs","sources":["../../src/useLoaderData.tsx"],"sourcesContent":["import { useMatch } from './useMatch'\nimport type { RegisteredRouter } from './router'\nimport type { AnyRoute } from './route'\nimport type { MakeRouteMatch } from './Matches'\nimport type { RouteIds } from './routeInfo'\nimport type { Constrain, StrictOrFrom } from './utils'\n\nexport type UseLoaderDataOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TStrict extends boolean,\n  TRouteMatch extends MakeRouteMatch<TRouteTree, TFrom, TStrict>,\n  TSelected,\n> = StrictOrFrom<Constrain<TFrom, RouteIds<TRouteTree>>, TStrict> & {\n  select?: (match: Required<TRouteMatch>['loaderData']) => TSelected\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TRouteMatch extends MakeRouteMatch<\n    TRouteTree,\n    TFrom,\n    TStrict\n  > = MakeRouteMatch<TRouteTree, TFrom, TStrict>,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: UseLoaderDataOptions<\n    TRouteTree,\n    TFrom,\n    TStrict,\n    TRouteMatch,\n    TSelected\n  >,\n): TSelected {\n  return useMatch<TRouteTree, TFrom, TStrict, TRouteMatch, TSelected>({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s.loaderData)\n        : (s.loaderData as TSelected)\n    },\n  })\n}\n"],"names":["useMatch"],"mappings":";;;AAiBO,SAAS,cAWd,MAOW;AACX,SAAOA,kBAA6D;AAAA,IAClE,GAAG;AAAA,IACH,QAAQ,CAAC,MAAM;AACN,aAAA,OAAO,KAAK,WAAW,aAC1B,KAAK,OAAO,EAAE,UAAU,IACvB,EAAE;AAAA,IACT;AAAA,EAAA,CACD;AACH;;"}